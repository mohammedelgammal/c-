#ifndef SOLUTION
#define SOLUTION

#include <functional>

using std::function;
using std::max;
using std::string;
using std::unordered_map;
using std::vector;

// recursive solution tcO(2^m+n) scO(min(m,n))
// int longestCommonSubsequence(string text1, string text2) {
//   int size1 = text1.size();
//   int size2 = text2.size();

//   function<int(int, int)> lcs = [&](int i, int j) {
//     if (i >= size1 || j >= size2)
//       return 0;
//     if (text1[i] == text2[j])
//       return 1 + lcs(i + 1, j);
//     return max(lcs(i + 1, j), lcs(i, j + 1));
//   };

//   return lcs(0, 0);
// }

// dp memoization tcO(m.n) scO(m.n)
// int longestCommonSubsequence(string text1, string text2) {
//   int size1 = text1.size();
//   int size2 = text2.size();
//   unordered_map<int, unordered_map<int, int>> memo;

//   function<int(int, int)> lcs = [&](int i, int j) {
//     if (i >= size1 || j >= size2)
//       return 0;
//     if (text1[i] == text2[j])
//       return 1 + lcs(i + 1, j);
//     if (memo.count(i) && memo[i].count(j))
//       return memo[i][j];
//     memo[i][j] = max(lcs(i + 1, j), lcs(i, j + 1));
//     return memo[i][j];
//   };

//   return lcs(0, 0);
// }

// dp bottom-up tcO(m.n) sc(m.n)
int longestCommonSubsequence(string text1, string text2) {
  int rows = text1.size(), cols = text2.size();
  vector<vector<int>> dp(rows + 1, vector<int>(cols + 1, 0));
  for (int i = rows - 1; i >= 0; i--) {
    for (int j = cols - 1; j >= 0; j--) {
      if (text1[i] == text2[j])
        dp[i][j] = 1 + dp[i + 1][j + 1];
      else
        dp[i][j] = max(dp[i + 1][j], dp[i][j + 1]);
    }
  }
  return dp[0][0];
}

#endif // SOLUTION